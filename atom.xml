<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://20195468.github.io</id>
    <title>Gridea</title>
    <updated>2020-10-24T05:28:37.808Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://20195468.github.io"/>
    <link rel="self" href="https://20195468.github.io/atom.xml"/>
    <subtitle>panghuhu&apos;s blog</subtitle>
    <logo>https://20195468.github.io/images/avatar.png</logo>
    <icon>https://20195468.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[树的线索遍历（基本原理描述，无代码实现）]]></title>
        <id>https://20195468.github.io/post/shu-de-xian-suo-bian-li-ji-ben-yuan-li-miao-shu-wu-dai-ma-shi-xian/</id>
        <link href="https://20195468.github.io/post/shu-de-xian-suo-bian-li-ji-ben-yuan-li-miao-shu-wu-dai-ma-shi-xian/">
        </link>
        <updated>2020-10-24T03:06:29.000Z</updated>
        <content type="html"><![CDATA[<p>树的线索遍历包括前序，中序，后序三种线索遍历方式。</p>
<p>线索二叉树的数据结构</p>
<p><img src="https://20195468.github.io/post-images/1603508854944.png" alt="" loading="lazy"><br>
​                                                                                                                                                                                    （图一）</p>
<p>ltag=0： lchild指示结点的左孩子。</p>
<p>ltag=1：lchild指示结点的前驱。</p>
<p>rtag=0： rchild指示结点的右孩子。</p>
<p>rtag=1：rchild指示结点的后继。</p>
<h2 id="前序线索遍历根左右">前序线索遍历（根左右）</h2>
<p>线索遍历即找其前驱和后继。</p>
<p>给一个前序线索二叉树，如何根据该树找到当前节点通过前序遍历的前驱和后继。</p>
<h3 id="前驱">前驱</h3>
<p>根据二叉树的结构    当一个结点</p>
<p>ltag=1时  该结点的前驱为lchild所指向的位置。</p>
<p>但当ltag=0时该结点的前驱是谁呢？<br>
例如<img src="https://20195468.github.io/post-images/1603508965693.png" alt="" loading="lazy"><br>
​                                   （图二）https://www.cnblogs.com/meihao1203/p/9224550.html?utm_source=tuicool<br>
对于H结点 该结点的前驱为D（双亲），而I结点的前驱为H（兄弟结点）</p>
<p>观察可知H为其双亲的左孩子结点，I结点为其双亲的右孩子结点。</p>
<p>所以当ltag=0时</p>
<p>（1）若当前结点为其双亲结点的左孩子结点，则该结点的前驱为其双亲结点</p>
<p>（2）若当前结点为其双亲节点的右孩子结点，如果该节点有兄弟结点，则该结点的前驱为以其兄弟结点为根节点的二叉树最后遍历的结点（该树的最右侧叶子结点）</p>
<p>（3）若当前结点为二叉树的根结点，其前驱为空。</p>
<h3 id="后继">后继</h3>
<p>对于前序遍历来说，其后继的寻找是一个非常简单的事情。</p>
<p>当rtag=1时  后继结点为lchild指向的结点。</p>
<p>rtag=0时   若其左孩子存在后继结点为其左孩子，否则为其右孩子（两个孩子均不存在的情况不可能出现，因为若其右孩子不存在则rtag=1，不符合当前情况）</p>
<h2 id="中序线索遍历左根右">中序线索遍历（左根右）</h2>
<figure data-type="image" tabindex="1"><img src="https://20195468.github.io/post-images/1603516922461.png" alt="" loading="lazy"></figure>
<p>​                                              （图三）https://blog.csdn.net/KevinsCSDN/article/details/80689161</p>
<h3 id="前驱-2">前驱</h3>
<p>ltag=1时：lchild指向结点为其前驱</p>
<p>ltag=0时：前驱为遍历左子树时最后一访问的一个结点（左子树中最右下结点）</p>
<h3 id="后继-2">后继</h3>
<p>rtag=1时：rchild指向为其后继</p>
<p>rtag=0时：结点的后继为遍历右子树时访问的第一个结点（右子树中最左下结点）</p>
<h2 id="后序线索遍历左右根">后序线索遍历（左右根）</h2>
<figure data-type="image" tabindex="2"><img src="https://20195468.github.io/post-images/1603516984003.png" alt="" loading="lazy"></figure>
<h3 id="前驱-3">前驱</h3>
<p>ltag=1时  lchild指向的结点即为前驱</p>
<p>ltag=0时 当右孩子存在时前驱结点为其右孩子结点<br>
例如：<br>
<img src="https://20195468.github.io/post-images/1603517124963.png" alt="" loading="lazy"><br>
​				                                                                             （图五）<br>
当右孩子节点不存在时其前驱结点为左孩子结点（左孩子结点一定存在  因为此时ltag=0）<br>
例如：<br>
<img src="https://20195468.github.io/post-images/1603517175170.png" alt="" loading="lazy"><br>
​                                                                                  （图六）</p>
<h3 id="后继-3">后继</h3>
<p>rtag=1时  其指向结点为后继结点</p>
<p>rtag=0时  （1）若为二叉树的根结点则后继结点为空（如图四中的A结点）</p>
<p>​				 （2）若当前结点为双亲的右孩子结点或者是双亲的左孩子且其双亲没有右子树，则其后继结点为其双亲结点（如图五和图六					中的B结点）</p>
<p>​				（3）若当前节点是其双亲的左孩子，且其双亲有右子树，则其后继结点为双亲的右子树上按后序遍历列出的第一个结点（如图四中的B结点）<br>
​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[反转链表（java实现）]]></title>
        <id>https://20195468.github.io/post/fan-zhuan-lian-biao-java-shi-xian/</id>
        <link href="https://20195468.github.io/post/fan-zhuan-lian-biao-java-shi-xian/">
        </link>
        <updated>2020-10-20T03:24:30.000Z</updated>
        <content type="html"><![CDATA[<p>题目描述：定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<p>示例：</p>
<pre><code>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL
</code></pre>
<p>限制：</p>
<pre><code>0 &lt;= 节点个数 &lt;= 5000 
</code></pre>
<h2 id="一非迭代解法双指针法">一：非迭代解法（双指针法）</h2>
<p>申请两个指针分别为previous和current</p>
<p>current：表示当前链表的位置（初始化指向头指针）</p>
<p>previous：表示前一位置（初始化指向空）</p>
<p>链表反转时，当前节点指向前一节点</p>
<p>即：current.next = previous;</p>
<p><strong>(值得注意的是，当该步骤执行后，当前节点的下一节点会丢失</strong></p>
<p><strong>解决方法：在该步骤之前再申请一节点（temp）保存当前节点的下一节点位置。</strong></p>
<p><strong>即：temp=current.next；)</strong></p>
<p>后 当前指针和前一指针向前移动</p>
<p>previous = current;</p>
<p>current = temp;</p>
<p>完整代码为：</p>
<pre><code>ListNode pre = null;
ListNode current = head;
ListNode temp = null;
while (current != null) {
    //保存后一个结点的位置
    temp = current.next;
    //将当前节点指向上一节点
    current.next = pre;
    //当前和前一位置向后移动
    pre = current;
    current = temp;
}
return pre;
</code></pre>
<h2 id="二递归解法">二：递归解法</h2>
<p>递归问题：1：一个问题可以分为若干个子问题</p>
<p>​                   2：某些子问题是原子的，另外一些子问题与原问题的逻辑相同</p>
<p>​					典型的有<strong>汉诺塔问题，求阶乘</strong>等</p>
<p>​					**注：**然而对于一个问题，能用循环就不用递归（前提是循环结构实现起来比较简单）</p>
<p>​							递归问题的本质实质就是对栈的使用。</p>
<p>递归结构：</p>
<pre><code>public Status digui(参数0,1,2...){

​		if(终止条件){

​			return;

​		}

​		逻辑处理（原子，可以存在也可以不存在）

​		//递归调用

​		digui(参数0,1,2...)；

​		逻辑处理（原子，可以存在也可以不存在）

}
</code></pre>
<p>对于本题递归时从链表的末尾进行翻转，依次向前</p>
<p>代码实现</p>
<pre><code>public ListNode reverseList(ListNode head) {
    //终止条件当前为空或者下一节点为空
    if (head == null || head.next == null)
        return head;
    //递归调用，找到链表末尾
    ListNode current = reverseList(head.next);
    //对节点进行翻转
    ListNode temp = head.next;
    temp.next = head;
    //此时head表示链表的最后一个节点，应指向null
    head.next = null;
    return current;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[区块链技术——比特币原理]]></title>
        <id>https://20195468.github.io/post/qu-kuai-lian-ji-zhu-bi-te-bi-yuan-li/</id>
        <link href="https://20195468.github.io/post/qu-kuai-lian-ji-zhu-bi-te-bi-yuan-li/">
        </link>
        <updated>2020-10-16T03:52:16.000Z</updated>
        <content type="html"><![CDATA[<p>谈及区块链技术就免不了谈比特币。也就是说比特币是区块链的一种典型表现形式。<br>
通过比特币来学习区块链中的核心技术</p>
<h2 id="一什么是比特币">一：什么是比特币</h2>
<p>比特币是一种分布式的点对点的<strong>数字货币</strong>。可以在世界上任何两个人之间<strong>及时</strong>（instantly）</p>
<p><strong>安全地</strong>（securely）进行货币交换。<br>
从某种意义上说它更像一种纯粹的电子货币。（区别于支付宝，微信的支付方式）</p>
<h2 id="二比特币的由来与发展">二：比特币的由来与发展</h2>
<p>创始人：中本聪（一位神秘的比特币大佬）</p>
<ol start="2008">
<li></li>
</ol>
<p>•8月 “bitcoin.org” 域名注册</p>
<p>•10月学术文章《比特币：一种点对点式的电子现金系统》（Bitcoin: A Peer-to-Peer Electronic Cash System）发表</p>
<p>•11月 比特币项目上线</p>
<p>2009</p>
<p>•01.03 比特币的第一个区块（创世块）产生 18:15:05 GMT</p>
<p>•01.12 比特币的第一个交易产生：第170块 From Satoshi to Hal Finney</p>
<p>经过近十年的发展，比特币蒸蒸日上，并在18年创下了价值巅峰。<br>
<img src="https://20195468.github.io/post-images/1602821870609.png" alt="" loading="lazy"></p>
<h2 id="三比特币的特点">三：比特币的特点</h2>
<p>去中心化 Decentralized</p>
<p>分布式 Distributed</p>
<p>民主自治的 Democratic</p>
<p>匿名保护隐私的Anonymous</p>
<p>方便快捷 Fast, cheap, and irreversible</p>
<p>安全 Secure</p>
<p>无双花No double spending</p>
<p>持续更新中......</p>
]]></content>
    </entry>
</feed>